{
    "problems": [{
            "problem_title": "206. Reverse Linked List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:11:46",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return prev",
                "solving_duration_seconds": 21.26,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "111. Minimum Depth of Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:12:21",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))",
                "solving_duration_seconds": 19.26,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "326. Power of Three",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:12:55",
            "details": {
                "final_code": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        \n        max_power_of_three = 3**19  # 3^19 is the largest power of 3 within the 32-bit integer range\n        return max_power_of_three % n == 0",
                "solving_duration_seconds": 20.01,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "283. Move Zeroes",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:13:30",
            "details": {
                "final_code": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        left = 0\n        for right in range(len(nums)):\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1",
                "solving_duration_seconds": 20.2,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "263. Ugly Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:14:05",
            "details": {
                "final_code": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        \n        return n == 1",
                "solving_duration_seconds": 20.1,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "345. Reverse Vowels of a String",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:14:40",
            "details": {
                "final_code": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = \"aeiouAEIOU\"\n        s_list = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s_list[left] not in vowels:\n                left += 1\n            while left < right and s_list[right] not in vowels:\n                right -= 1\n            if left < right:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n        return \"\".join(s_list)",
                "solving_duration_seconds": 20.48,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "190. Reverse Bits",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:15:14",
            "details": {
                "final_code": "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        result = 0\n        for i in range(32):\n            bit = (n >> i) & 1\n            result |= bit << (31 - i)\n        return result",
                "solving_duration_seconds": 19.9,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "13. Roman to Integer",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:15:50",
            "details": {
                "final_code": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        for i in range(len(s)):\n            if i + 1 < len(s) and roman_map[s[i]] < roman_map[s[i+1]]:\n                result -= roman_map[s[i]]\n            else:\n                result += roman_map[s[i]]\n        return result",
                "solving_duration_seconds": 20.33,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "234. Palindrome Linked List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:16:21",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: bool\n        \"\"\"\n        # Find the middle of the linked list using slow and fast pointers\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Reverse the second half of the linked list\n        prev = None\n        curr = slow\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        # Compare the first half and the reversed second half\n        left = head\n        right = prev\n        while right:\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n\n        return True",
                "solving_duration_seconds": 15.67,
                "solving_duration_formatted": "0:00:15"
            }
        },
        {
            "problem_title": "242. Valid Anagram",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:16:47",
            "details": {
                "final_code": "def isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n\n    s_count = {}\n    t_count = {}\n\n    for char in s:\n        s_count[char] = s_count.get(char, 0) + 1\n\n    for char in t:\n        t_count[char] = t_count.get(char, 0) + 1\n\n    return s_count == t_count",
                "solving_duration_seconds": 11.62,
                "solving_duration_formatted": "0:00:11"
            }
        },
        {
            "problem_title": "160. Intersection of Two Linked Lists",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:17:22",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not headA or not headB:\n            return None\n\n        a = headA\n        b = headB\n\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n\n        return a",
                "solving_duration_seconds": 20.4,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "303. Range Sum Query - Immutable",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:17:55",
            "details": {
                "final_code": "class NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.prefix_sums = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i]\n\n    def sumRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]",
                "solving_duration_seconds": 17.97,
                "solving_duration_formatted": "0:00:17"
            }
        },
        {
            "problem_title": "344. Reverse String",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:18:31",
            "details": {
                "final_code": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        l, r = 0, len(s) - 1\n        while l < r:\n            s[l], s[r] = s[r], s[l]\n            l += 1\n            r -= 1",
                "solving_duration_seconds": 18.94,
                "solving_duration_formatted": "0:00:18"
            }
        },
        {
            "problem_title": "383. Ransom Note",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:19:06",
            "details": {
                "final_code": "class Solution(object):\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        :type ransomNote: str\n        :type magazine: str\n        :rtype: bool\n        \"\"\"\n        from collections import Counter\n        magazine_counts = Counter(magazine)\n        for char in ransomNote:\n            if magazine_counts[char] > 0:\n                magazine_counts[char] -= 1\n            else:\n                return False\n        return True",
                "solving_duration_seconds": 19.93,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "338. Counting Bits",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:19:40",
            "details": {
                "final_code": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans",
                "solving_duration_seconds": 18.94,
                "solving_duration_formatted": "0:00:18"
            }
        },
        {
            "problem_title": "94. Binary Tree Inorder Traversal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:20:17",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        stack = []\n        curr = root\n\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n\n        return res",
                "solving_duration_seconds": 21.46,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "268. Missing Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:20:52",
            "details": {
                "final_code": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        expected_sum = n * (n + 1) // 2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum",
                "solving_duration_seconds": 19.96,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "100. Same Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:21:27",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: Optional[TreeNode]\n        :type q: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "solving_duration_seconds": 20.38,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "392. Is Subsequence",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:22:01",
            "details": {
                "final_code": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        i, j = 0, 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)",
                "solving_duration_seconds": 18.92,
                "solving_duration_formatted": "0:00:18"
            }
        },
        {
            "problem_title": "171. Excel Sheet Column Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:22:35",
            "details": {
                "final_code": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result",
                "solving_duration_seconds": 19.97,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "217. Contains Duplicate",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:23:12",
            "details": {
                "final_code": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False",
                "solving_duration_seconds": 21.13,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "14. Longest Common Prefix",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:23:46",
            "details": {
                "final_code": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n        \n        shortest = min(strs, key=len)\n        \n        for i, char in enumerate(shortest):\n            for other in strs:\n                if other[i] != char:\n                    return shortest[:i]\n        return shortest",
                "solving_duration_seconds": 18.88,
                "solving_duration_formatted": "0:00:18"
            }
        },
        {
            "problem_title": "222. Count Complete Tree Nodes",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:24:18",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n\n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n\n        if left_height == right_height:\n            return (1 << (left_height + 1)) - 1\n        else:\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n\n    def get_height(self, node):\n        height = 0\n        while node:\n            height += 1\n            node = node.left\n        return height",
                "solving_duration_seconds": 16.81,
                "solving_duration_formatted": "0:00:16"
            }
        },
        {
            "problem_title": "58. Length of Last Word",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:24:53",
            "details": {
                "final_code": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.strip()\n        return len(s.split(\" \")[-1])",
                "solving_duration_seconds": 19.67,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "58. Length of Last Word",
            "status": "soved",
            "attempts": 0,
            "timestamp": "2025-04-19 16:25:09",
            "details": {
                "message": "Message: \nStacktrace:\n0   chromedriver                        0x0000000100826e10 cxxbridge1$str$ptr + 2817040\n1   chromedriver                        0x000000010081f0ac cxxbridge1$str$ptr + 2784940\n2   chromedriver                        0x00000001003668d8 cxxbridge1$string$len + 93028\n3   chromedriver                        0x00000001003ad6a0 cxxbridge1$string$len + 383276\n4   chromedriver                        0x00000001003ee7b8 cxxbridge1$string$len + 649796\n5   chromedriver                        0x00000001003a1a80 cxxbridge1$string$len + 335116\n6   chromedriver                        0x00000001007ebc98 cxxbridge1$str$ptr + 2575000\n7   chromedriver                        0x00000001007eef64 cxxbridge1$str$ptr + 2588004\n8   chromedriver                        0x00000001007cba20 cxxbridge1$str$ptr + 2443296\n9   chromedriver                        0x00000001007ef7e0 cxxbridge1$str$ptr + 2590176\n10  chromedriver                        0x00000001007bcb14 cxxbridge1$str$ptr + 2382100\n11  chromedriver                        0x000000010080f9c4 cxxbridge1$str$ptr + 2721732\n12  chromedriver                        0x000000010080fb50 cxxbridge1$str$ptr + 2722128\n13  chromedriver                        0x000000010081ecf8 cxxbridge1$str$ptr + 2783992\n14  libsystem_pthread.dylib             0x0000000185b642e4 _pthread_start + 136\n15  libsystem_pthread.dylib             0x0000000185b5f0fc thread_start + 8\n"
            }
        },
        {
            "problem_title": "145. Binary Tree Postorder Traversal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:25:46",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n\n        return result[::-1]",
                "solving_duration_seconds": 21.99,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "141. Linked List Cycle",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:26:22",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return False\n\n        slow = head\n        fast = head.next\n\n        while slow != fast:\n            if not fast or not fast.next:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n\n        return True",
                "solving_duration_seconds": 20.57,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "389. Find the Difference",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:26:56",
            "details": {
                "final_code": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        char_code_s = 0\n        char_code_t = 0\n\n        for char in s:\n            char_code_s += ord(char)\n\n        for char in t:\n            char_code_t += ord(char)\n\n        return chr(char_code_t - char_code_s)",
                "solving_duration_seconds": 19.98,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "226. Invert Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:27:25",
            "details": {
                "final_code": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root",
                "solving_duration_seconds": 12.5,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "231. Power of Two",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:27:52",
            "details": {
                "final_code": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0",
                "solving_duration_seconds": 11.92,
                "solving_duration_formatted": "0:00:11"
            }
        },
        {
            "problem_title": "405. Convert a Number to Hexadecimal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:28:20",
            "details": {
                "final_code": "class Solution:\n    def toHex(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n\n        hex_map = \"0123456789abcdef\"\n        result = \"\"\n\n        for _ in range(8):\n            digit = num & 0xf\n            result = hex_map[digit] + result\n            num >>= 4\n\n        # Remove leading zeros\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n\n        return result",
                "solving_duration_seconds": 12.25,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "290. Word Pattern",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:28:57",
            "details": {
                "final_code": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        pattern_map = {}\n        word_map = {}\n\n        for i in range(len(pattern)):\n            char = pattern[i]\n            word = words[i]\n\n            if char not in pattern_map and word not in word_map:\n                pattern_map[char] = word\n                word_map[word] = char\n            elif char in pattern_map and word in word_map:\n                if pattern_map[char] != word or word_map[word] != char:\n                    return False\n            else:\n                return False\n\n        return True",
                "solving_duration_seconds": 20.83,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "349. Intersection of Two Arrays",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:29:24",
            "details": {
                "final_code": "class Solution:\n    def intersection(self, nums1: list[int], nums2: list[int]) -> list[int]:\n        set1 = set(nums1)\n        set2 = set(nums2)\n        return list(set1.intersection(set2))",
                "solving_duration_seconds": 11.93,
                "solving_duration_formatted": "0:00:11"
            }
        },
        {
            "problem_title": "125. Valid Palindrome",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:29:51",
            "details": {
                "final_code": "def isPalindrome(s: str) -> bool:\n    l, r = 0, len(s) - 1\n    while l < r:\n        while l < r and not s[l].isalnum():\n            l += 1\n        while l < r and not s[r].isalnum():\n            r -= 1\n        if l < r and s[l].lower() != s[r].lower():\n            return False\n        l += 1\n        r -= 1\n    return True",
                "solving_duration_seconds": 12.01,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "367. Valid Perfect Square",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:30:19",
            "details": {
                "final_code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        low = 1\n        high = num\n\n        while low <= high:\n            mid = low + (high - low) // 2\n            square = mid * mid\n\n            if square == num:\n                return True\n            elif square < num:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return False",
                "solving_duration_seconds": 11.92,
                "solving_duration_formatted": "0:00:11"
            }
        },
        {
            "problem_title": "232. Implement Queue using Stacks",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:30:55",
            "details": {
                "final_code": "class MyQueue(object):\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x):\n        self.s1.append(x)\n\n    def pop(self):\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2.pop()\n\n    def peek(self):\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]\n\n    def empty(self):\n        return not self.s1 and not self.s2",
                "solving_duration_seconds": 18.72,
                "solving_duration_formatted": "0:00:18"
            }
        },
        {
            "problem_title": "228. Summary Ranges",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:31:31",
            "details": {
                "final_code": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        if not nums:\n            return []\n\n        result = []\n        start = nums[0]\n        end = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    result.append(str(start))\n                else:\n                    result.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n\n        if start == end:\n            result.append(str(start))\n        else:\n            result.append(str(start) + \"->\" + str(end))\n\n        return result",
                "solving_duration_seconds": 20.19,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "20. Valid Parentheses",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:32:09",
            "details": {
                "final_code": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack",
                "solving_duration_seconds": 21.69,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "441. Arranging Coins",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:32:44",
            "details": {
                "final_code": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            coins_needed = (mid * (mid + 1)) // 2\n            if coins_needed == n:\n                return mid\n            elif coins_needed < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right",
                "solving_duration_seconds": 19.66,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "342. Power of Four",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:33:19",
            "details": {
                "final_code": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        \n        if (n & (n - 1)) != 0:\n            return False\n        \n        if (n & 0x55555555) == 0:\n            return False\n        \n        return True",
                "solving_duration_seconds": 20.72,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "258. Add Digits",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:33:53",
            "details": {
                "final_code": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 0\n        return (num - 1) % 9 + 1",
                "solving_duration_seconds": 19.05,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "234. Palindrome Linked List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:34:29",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: bool\n        \"\"\"\n        # Find the middle of the linked list using slow and fast pointers\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Reverse the second half of the linked list\n        prev = None\n        curr = slow\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        # Compare the first half and the reversed second half\n        left = head\n        right = prev\n        while right:\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n\n        return True",
                "solving_duration_seconds": 20.05,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "191. Number of 1 Bits",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:35:04",
            "details": {
                "final_code": "class Solution(object):\n    def hammingWeight(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        while n:\n            n &= (n - 1)\n            count += 1\n        return count",
                "solving_duration_seconds": 20.43,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "401. Binary Watch",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:35:39",
            "details": {
                "final_code": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append(\"%d:%02d\" % (h, m))\n        return res",
                "solving_duration_seconds": 19.84,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "461. Hamming Distance",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:36:14",
            "details": {
                "final_code": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        xor = x ^ y\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance",
                "solving_duration_seconds": 19.48,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "495. Teemo Attacking",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:36:49",
            "details": {
                "final_code": "class Solution(object):\n    def findPoisonedDuration(self, timeSeries, duration):\n        \"\"\"\n        :type timeSeries: List[int]\n        :type duration: int\n        :rtype: int\n        \"\"\"\n        total_poisoned = 0\n        for i in range(len(timeSeries) - 1):\n            total_poisoned += min(duration, timeSeries[i+1] - timeSeries[i])\n        if timeSeries:\n            total_poisoned += duration\n        return total_poisoned",
                "solving_duration_seconds": 19.66,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "168. Excel Sheet Column Title",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:37:24",
            "details": {
                "final_code": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            result = chr(ord('A') + columnNumber % 26) + result\n            columnNumber //= 26\n        return result",
                "solving_duration_seconds": 20.7,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "35. Search Insert Position",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:38:00",
            "details": {
                "final_code": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left",
                "solving_duration_seconds": 20.78,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "69. Sqrt(x)",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:38:34",
            "details": {
                "final_code": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        ans = 0\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid <= x // mid:\n                ans = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return ans",
                "solving_duration_seconds": 19.5,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "257. Binary Tree Paths",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:39:10",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[str]\n        \"\"\"\n        if not root:\n            return []\n\n        paths = []\n\n        def dfs(node, path):\n            if not node.left and not node.right:\n                paths.append(path + str(node.val))\n                return\n\n            if node.left:\n                dfs(node.left, path + str(node.val) + \"->\")\n            if node.right:\n                dfs(node.right, path + str(node.val) + \"->\")\n\n        dfs(root, \"\")\n        return paths",
                "solving_duration_seconds": 20.35,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "414. Third Maximum Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:39:45",
            "details": {
                "final_code": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        first_max = float('-inf')\n        second_max = float('-inf')\n        third_max = float('-inf')\n\n        for num in nums:\n            if num > first_max:\n                third_max = second_max\n                second_max = first_max\n                first_max = num\n            elif num > second_max and num < first_max:\n                third_max = second_max\n                second_max = num\n            elif num > third_max and num < second_max:\n                third_max = num\n\n        if third_max == float('-inf'):\n            return first_max\n        else:\n            return third_max",
                "solving_duration_seconds": 20.95,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "374. Guess Number Higher or Lower",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:40:21",
            "details": {
                "final_code": "# The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num):\n\nclass Solution(object):\n    def guessNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        low = 1\n        high = n\n        while low <= high:\n            mid = low + (high - low) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res == -1:\n                high = mid - 1\n            else:\n                low = mid + 1\n        return -1",
                "solving_duration_seconds": 21.21,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "219. Contains Duplicate II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:40:56",
            "details": {
                "final_code": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        seen = {}\n        for i, num in enumerate(nums):\n            if num in seen and i - seen[num] <= k:\n                return True\n            seen[num] = i\n        return False",
                "solving_duration_seconds": 20.45,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "70. Climbing Stairs",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:41:33",
            "details": {
                "final_code": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 2:\n            return n\n        \n        a = 1\n        b = 2\n        \n        for i in range(3, n + 1):\n            temp = a + b\n            a = b\n            b = temp\n            \n        return b",
                "solving_duration_seconds": 19.81,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "506. Relative Ranks",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:42:07",
            "details": {
                "final_code": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        n = len(score)\n        ranks = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"]\n        \n        indexed_scores = sorted([(score[i], i) for i in range(n)], reverse=True)\n        \n        result = [None] * n\n        \n        for i in range(n):\n            original_index = indexed_scores[i][1]\n            if i < 3:\n                result[original_index] = ranks[i]\n            else:\n                result[original_index] = str(i + 1)\n        \n        return result",
                "solving_duration_seconds": 19.83,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "409. Longest Palindrome",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:42:42",
            "details": {
                "final_code": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        counts = {}\n        for char in s:\n            counts[char] = counts.get(char, 0) + 1\n        \n        length = 0\n        odd_found = False\n        \n        for count in counts.values():\n            if count % 2 == 0:\n                length += count\n            else:\n                length += count - 1\n                odd_found = True\n        \n        if odd_found:\n            length += 1\n        \n        return length",
                "solving_duration_seconds": 19.45,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "412. Fizz Buzz",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:43:18",
            "details": {
                "final_code": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        answer = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer",
                "solving_duration_seconds": 20.96,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "530. Minimum Absolute Difference in BST",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:43:54",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.min_diff = float('inf')\n        self.prev = None\n\n        def inorder(node):\n            if not node:\n                return\n\n            inorder(node.left)\n\n            if self.prev is not None:\n                self.min_diff = min(self.min_diff, node.val - self.prev)\n\n            self.prev = node.val\n\n            inorder(node.right)\n\n        inorder(root)\n        return self.min_diff",
                "solving_duration_seconds": 20.14,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "350. Intersection of Two Arrays II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:44:28",
            "details": {
                "final_code": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        from collections import Counter\n        count1 = Counter(nums1)\n        count2 = Counter(nums2)\n        \n        result = []\n        for num in count1:\n            if num in count2:\n                result.extend([num] * min(count1[num], count2[num]))\n        return result",
                "solving_duration_seconds": 19.95,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "557. Reverse Words in a String III",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:45:02",
            "details": {
                "final_code": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        words = s.split()\n        reversed_words = [word[::-1] for word in words]\n        return \" \".join(reversed_words)",
                "solving_duration_seconds": 19.03,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "278. First Bad Version",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:45:36",
            "details": {
                "final_code": "# The isBadVersion API is already defined for you.\n# @param version, an integer\n# @return a bool\n# def isBadVersion(version):\n\nclass Solution(object):\n    def firstBadVersion(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left = 1\n        right = n\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
                "solving_duration_seconds": 19.54,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "507. Perfect Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:46:11",
            "details": {
                "final_code": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 1:\n            return False\n        \n        sum_of_divisors = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                sum_of_divisors += i\n                sum_of_divisors += num // i\n        \n        return sum_of_divisors == num",
                "solving_duration_seconds": 19.8,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "482. License Key Formatting",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:46:46",
            "details": {
                "final_code": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n == 0:\n            return \"\"\n        first_group_len = n % k\n        result = \"\"\n        if first_group_len > 0:\n            result += s[:first_group_len]\n            if n > first_group_len:\n                result += '-'\n        \n        for i in range(first_group_len, n, k):\n            result += s[i:i+k]\n            if i + k < n:\n                result += '-'\n        \n        return result",
                "solving_duration_seconds": 19.87,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "404. Sum of Left Leaves",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:47:22",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n\n        total_sum = 0\n\n        if root.left:\n            if not root.left.left and not root.left.right:\n                total_sum += root.left.val\n            else:\n                total_sum += self.sumOfLeftLeaves(root.left)\n\n        total_sum += self.sumOfLeftLeaves(root.right)\n\n        return total_sum",
                "solving_duration_seconds": 20.08,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "543. Diameter of Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:47:51",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        diameter = 0\n\n        def height(node):\n            nonlocal diameter\n            if not node:\n                return 0\n            \n            left_height = height(node.left)\n            right_height = height(node.right)\n\n            diameter = max(diameter, left_height + right_height)\n\n            return 1 + max(left_height, right_height)\n\n        height(root)\n        return diameter",
                "solving_duration_seconds": 12.66,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "559. Maximum Depth of N-ary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:48:19",
            "details": {
                "final_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if not root:\n            return 0\n        \n        if not root.children:\n            return 1\n        \n        max_child_depth = 0\n        for child in root.children:\n            max_child_depth = max(max_child_depth, self.maxDepth(child))\n        \n        return 1 + max_child_depth",
                "solving_duration_seconds": 12.62,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "563. Binary Tree Tilt",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:48:56",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findTilt(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.tilt_sum = 0\n\n        def subtree_sum(node):\n            if not node:\n                return 0\n            \n            left_sum = subtree_sum(node.left)\n            right_sum = subtree_sum(node.right)\n            \n            self.tilt_sum += abs(left_sum - right_sum)\n            \n            return node.val + left_sum + right_sum\n\n        subtree_sum(root)\n        return self.tilt_sum",
                "solving_duration_seconds": 20.93,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "292. Nim Game",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:49:32",
            "details": {
                "final_code": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0",
                "solving_duration_seconds": 20.19,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "110. Balanced Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:50:08",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        def height(node):\n            if not node:\n                return 0\n            \n            left_height = height(node.left)\n            right_height = height(node.right)\n            \n            if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n                return -1\n            \n            return max(left_height, right_height) + 1\n        \n        return height(root) != -1",
                "solving_duration_seconds": 21.39,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "415. Add Strings",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:50:44",
            "details": {
                "final_code": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        result = \"\"\n\n        while i >= 0 or j >= 0 or carry:\n            digit1 = int(num1[i]) if i >= 0 else 0\n            digit2 = int(num2[j]) if j >= 0 else 0\n\n            sum_digits = digit1 + digit2 + carry\n            carry = sum_digits // 10\n            digit = sum_digits % 10\n\n            result = str(digit) + result\n\n            i -= 1\n            j -= 1\n\n        return result",
                "solving_duration_seconds": 20.88,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "448. Find All Numbers Disappeared in an Array",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:51:19",
            "details": {
                "final_code": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        result = []\n        for i in range(n):\n            if nums[i] > 0:\n                result.append(i + 1)\n        \n        return result",
                "solving_duration_seconds": 19.86,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "590. N-ary Tree Postorder Traversal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:51:54",
            "details": {
                "final_code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n\n            if node.children:\n                stack.extend(node.children)\n\n        return result[::-1]",
                "solving_duration_seconds": 19.94,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "501. Find Mode in Binary Search Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:52:31",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        self.count = 0\n        self.max_count = 0\n        self.mode = []\n        self.pre = None\n\n        def inorder(node):\n            if not node:\n                return\n\n            inorder(node.left)\n\n            if self.pre == None:\n                self.count = 1\n            elif self.pre.val == node.val:\n                self.count += 1\n            else:\n                self.count = 1\n\n            if self.count > self.max_count:\n                self.max_count = self.count\n                self.mode = [node.val]\n            elif self.count == self.max_count:\n                self.mode.append(node.val)\n\n            self.pre = node\n            inorder(node.right)\n\n        inorder(root)\n        return self.mode",
                "solving_duration_seconds": 20.27,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "434. Number of Segments in a String",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:53:06",
            "details": {
                "final_code": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())",
                "solving_duration_seconds": 19.42,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "551. Student Attendance Record I",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:53:41",
            "details": {
                "final_code": "class Solution(object):\n    def checkRecord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        absent_count = 0\n        for i in range(len(s)):\n            if s[i] == 'A':\n                absent_count += 1\n                if absent_count >= 2:\n                    return False\n            if s[i] == 'L':\n                if i + 2 < len(s) and s[i+1] == 'L' and s[i+2] == 'L':\n                    return False\n        return True",
                "solving_duration_seconds": 19.63,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "476. Number Complement",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:54:15",
            "details": {
                "final_code": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        mask = 0\n        n = num\n        while n:\n            mask = (mask << 1) | 1\n            n >>= 1\n        return num ^ mask",
                "solving_duration_seconds": 19.38,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "2563. Count the Number of Fair Pairs",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:54:52",
            "details": {
                "final_code": "class Solution(object):\n    def countFairPairs(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            left = i + 1\n            right = n - 1\n            lower_bound = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[i] + nums[mid] >= lower:\n                    lower_bound = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n\n            left = i + 1\n            right = n - 1\n            upper_bound = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[i] + nums[mid] <= upper:\n                    upper_bound = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n            if lower_bound != -1 and upper_bound != -1:\n                if lower_bound <= upper_bound:\n                    count += (upper_bound - lower_bound + 1)\n        return count",
                "solving_duration_seconds": 20.68,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "520. Detect Capital",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:55:26",
            "details": {
                "final_code": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        n = len(word)\n        if n == 1:\n            return True\n        \n        if word[0].isupper():\n            if word[1].isupper():\n                for i in range(2, n):\n                    if word[i].islower():\n                        return False\n                return True\n            else:\n                for i in range(2, n):\n                    if word[i].isupper():\n                        return False\n                return True\n        else:\n            for i in range(1, n):\n                if word[i].isupper():\n                    return False\n            return True",
                "solving_duration_seconds": 19.78,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "637. Average of Levels in Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:56:02",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def averageOfLevels(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[float]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        queue = [root]\n\n        while queue:\n            level_sum = 0\n            level_size = len(queue)\n\n            for _ in range(level_size):\n                node = queue.pop(0)\n                level_sum += node.val\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.append(float(level_sum) / level_size)\n\n        return result",
                "solving_duration_seconds": 20.05,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "572. Subtree of Another Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:56:38",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSubtree(self, root, subRoot):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type subRoot: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        def is_same(root1, root2):\n            if not root1 and not root2:\n                return True\n            if not root1 or not root2:\n                return False\n            if root1.val != root2.val:\n                return False\n            return is_same(root1.left, root2.left) and is_same(root1.right, root2.right)\n\n        if not root:\n            return not subRoot\n\n        if is_same(root, subRoot):\n            return True\n\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)",
                "solving_duration_seconds": 20.55,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "496. Next Greater Element I",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:57:13",
            "details": {
                "final_code": "class Solution(object):\n    def nextGreaterElement(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stack = []\n        next_greater = {}\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        \n        result = []\n        for num in nums1:\n            result.append(next_greater.get(num, -1))\n        \n        return result",
                "solving_duration_seconds": 19.93,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "112. Path Sum",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:57:49",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return root.val == targetSum\n        \n        targetSum -= root.val\n        \n        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)",
                "solving_duration_seconds": 20.89,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "598. Range Addition II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:58:26",
            "details": {
                "final_code": "class Solution(object):\n    def maxCount(self, m, n, ops):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type ops: List[List[int]]\n        :rtype: int\n        \"\"\"\n        min_a = m\n        min_b = n\n        for op in ops:\n            min_a = min(min_a, op[0])\n            min_b = min(min_b, op[1])\n        return min_a * min_b",
                "solving_duration_seconds": 21.05,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "459. Repeated Substring Pattern",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:59:01",
            "details": {
                "final_code": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                substring = s[:i]\n                repeated_string = substring * (n // i)\n                if repeated_string == s:\n                    return True\n        return False",
                "solving_duration_seconds": 20.4,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "521. Longest Uncommon Subsequence I",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 16:59:38",
            "details": {
                "final_code": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))",
                "solving_duration_seconds": 20.92,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "492. Construct the Rectangle",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:00:13",
            "details": {
                "final_code": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        w = int(area**0.5)\n        while area % w != 0:\n            w -= 1\n        return [area / w, w]",
                "solving_duration_seconds": 20.51,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "680. Valid Palindrome II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:00:50",
            "details": {
                "final_code": "class Solution(object):\n    def validPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        def is_palindrome(s, left, right):\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n            left += 1\n            right -= 1\n        return True",
                "solving_duration_seconds": 20.91,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "653. Two Sum IV - Input is a BST",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:01:18",
            "details": {
                "final_code": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        nums = set()\n\n        def inorder(node):\n            if not node:\n                return False\n            \n            if inorder(node.left):\n                return True\n            \n            if k - node.val in nums:\n                return True\n            \n            nums.add(node.val)\n            \n            if inorder(node.right):\n                return True\n            \n            return False\n\n        return inorder(root)",
                "solving_duration_seconds": 12.52,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "674. Longest Continuous Increasing Subsequence",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:01:46",
            "details": {
                "final_code": "class Solution:\n    def findLengthOfLCIS(self, nums: list[int]) -> int:\n        if not nums:\n            return 0\n\n        max_len = 1\n        curr_len = 1\n\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                curr_len += 1\n                max_len = max(max_len, curr_len)\n            else:\n                curr_len = 1\n\n        return max_len",
                "solving_duration_seconds": 12.3,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "645. Set Mismatch",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:02:14",
            "details": {
                "final_code": "class Solution:\n    def findErrorNums(self, nums: list[int]) -> list[int]:\n        n = len(nums)\n        num_sum = sum(nums)\n        num_set_sum = sum(set(nums))\n        expected_sum = n * (n + 1) // 2\n        \n        duplicate = num_sum - num_set_sum\n        missing = expected_sum - num_set_sum\n        \n        return [duplicate, missing]",
                "solving_duration_seconds": 12.12,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "617. Merge Two Binary Trees",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:02:42",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n\n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n\n        return root1",
                "solving_duration_seconds": 12.83,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "104. Maximum Depth of Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:03:10",
            "details": {
                "final_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return max(left_depth, right_depth) + 1",
                "solving_duration_seconds": 12.25,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "599. Minimum Index Sum of Two Lists",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:03:38",
            "details": {
                "final_code": "def findRestaurant(list1: list[str], list2: list[str]) -> list[str]:\n    index_map = {s: i for i, s in enumerate(list1)}\n    min_sum = float('inf')\n    result = []\n    for j, s in enumerate(list2):\n        if s in index_map:\n            i = index_map[s]\n            current_sum = i + j\n            if current_sum < min_sum:\n                min_sum = current_sum\n                result = [s]\n            elif current_sum == min_sum:\n                result.append(s)\n    return result",
                "solving_duration_seconds": 12.14,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "682. Baseball Game",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:04:05",
            "details": {
                "final_code": "class Solution:\n    def calPoints(self, operations: list[str]) -> int:\n        record = []\n        for op in operations:\n            if op == '+':\n                record.append(record[-1] + record[-2])\n            elif op == 'D':\n                record.append(2 * record[-1])\n            elif op == 'C':\n                record.pop()\n            else:\n                record.append(int(op))\n        return sum(record)",
                "solving_duration_seconds": 12.28,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "671. Second Minimum Node In a Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:04:34",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return -1\n\n        min_val = root.val\n        second_min = float('inf')\n\n        def dfs(node):\n            nonlocal second_min\n            if not node:\n                return\n\n            if node.val > min_val and node.val < second_min:\n                second_min = node.val\n\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n\n        return second_min if second_min != float('inf') else -1",
                "solving_duration_seconds": 12.78,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "628. Maximum Product of Three Numbers",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:05:01",
            "details": {
                "final_code": "class Solution:\n    def maximumProduct(self, nums: list[int]) -> int:\n        nums.sort()\n        return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",
                "solving_duration_seconds": 11.89,
                "solving_duration_formatted": "0:00:11"
            }
        },
        {
            "problem_title": "594. Longest Harmonious Subsequence",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:05:30",
            "details": {
                "final_code": "def findLHS(nums: list[int]) -> int:\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    \n    max_length = 0\n    for num in counts:\n        if num + 1 in counts:\n            max_length = max(max_length, counts[num] + counts[num + 1])\n    \n    return max_length",
                "solving_duration_seconds": 12.39,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "657. Robot Return to Origin",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:05:57",
            "details": {
                "final_code": "class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = 0\n        y = 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'R':\n                x += 1\n            elif move == 'L':\n                x -= 1\n        return x == 0 and y == 0",
                "solving_duration_seconds": 12.37,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "387. First Unique Character in a String",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:06:25",
            "details": {
                "final_code": "def firstUniqChar(s: str) -> int:\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    \n    for i, char in enumerate(s):\n        if counts[char] == 1:\n            return i\n    \n    return -1",
                "solving_duration_seconds": 12.53,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "509. Fibonacci Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:06:53",
            "details": {
                "final_code": "class Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
                "solving_duration_seconds": 11.98,
                "solving_duration_formatted": "0:00:11"
            }
        }
    ],
    "statistics": {
        "total_attempted": 100,
        "total_solved": 100,
        "accuracy": 100.0
    }
}