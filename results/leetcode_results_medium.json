{
    "problems": [
        {
            "problem_title": "5. Longest Palindromic Substring",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:57:20",
            "details": {
                "final_code": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return \"\"\n\n        n = len(s)\n        if n == 1:\n            return s\n\n        longest_palindrome = \"\"\n\n        def expand_around_center(left, right):\n            while left >= 0 and right < n and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        for i in range(n):\n            # Odd length palindromes\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) > len(longest_palindrome):\n                longest_palindrome = palindrome1\n\n            # Even length palindromes\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) > len(longest_palindrome):\n                longest_palindrome = palindrome2\n\n        return longest_palindrome",
                "solving_duration_seconds": 26.96,
                "solving_duration_formatted": "0:00:26"
            }
        },
        {
            "problem_title": "19. Remove Nth Node From End of List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:57:56",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type n: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n\n        # Advance first pointer so that the gap between first and second is n nodes apart\n        for i in range(1, n + 2):\n            first = first.next\n\n        # Move first to the end, maintaining the gap\n        while first != None:\n            first = first.next\n            second = second.next\n\n        second.next = second.next.next\n\n        return dummy.next",
                "solving_duration_seconds": 21.2,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "49. Group Anagrams",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:58:31",
            "details": {
                "final_code": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagram_groups = {}\n        for s in strs:\n            sorted_s = \"\".join(sorted(s))\n            if sorted_s in anagram_groups:\n                anagram_groups[sorted_s].append(s)\n            else:\n                anagram_groups[sorted_s] = [s]\n        return list(anagram_groups.values())",
                "solving_duration_seconds": 20.68,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "6. Zigzag Conversion",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:59:07",
            "details": {
                "final_code": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n\n        rows = [''] * numRows\n        row_index = 0\n        direction = 1  # 1 for down, -1 for up\n\n        for char in s:\n            rows[row_index] += char\n\n            row_index += direction\n\n            if row_index == numRows:\n                row_index = numRows - 2\n                direction = -1\n            elif row_index < 0:\n                row_index = 1\n                direction = 1\n\n        return ''.join(rows)",
                "solving_duration_seconds": 21.31,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "82. Remove Duplicates from Sorted List II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 17:59:42",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                # Skip all duplicate nodes\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n\n        return dummy.next",
                "solving_duration_seconds": 20.0,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "18. 4Sum",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:00:18",
            "details": {
                "final_code": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n\n                left = j + 1\n                right = n - 1\n\n                while left < right:\n                    current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n\n                    if current_sum == target:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n\n                        left += 1\n                        right -= 1\n                    elif current_sum < target:\n                        left += 1\n                    else:\n                        right -= 1\n\n        return result",
                "solving_duration_seconds": 20.98,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "11. Container With Most Water",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:00:53",
            "details": {
                "final_code": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left < right:\n            width = right - left\n            min_height = min(height[left], height[right])\n            area = width * min_height\n            max_area = max(max_area, area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area",
                "solving_duration_seconds": 19.93,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "17. Letter Combinations of a Phone Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:01:28",
            "details": {
                "final_code": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n\n        result = []\n\n        def backtrack(combination, next_digits):\n            if not next_digits:\n                result.append(combination)\n                return\n\n            digit = next_digits[0]\n            letters = digit_to_letters[digit]\n            for letter in letters:\n                backtrack(combination + letter, next_digits[1:])\n\n        backtrack(\"\", digits)\n        return result",
                "solving_duration_seconds": 21.21,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "22. Generate Parentheses",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:02:03",
            "details": {
                "final_code": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        def backtrack(s, open_count, close_count):\n            if len(s) == 2 * n:\n                result.append(s)\n                return\n            if open_count < n:\n                backtrack(s + \"(\", open_count + 1, close_count)\n            if close_count < open_count:\n                backtrack(s + \")\", open_count, close_count + 1)\n        backtrack(\"\", 0, 0)\n        return result",
                "solving_duration_seconds": 19.69,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "62. Unique Paths",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:02:37",
            "details": {
                "final_code": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n            \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                \n        return dp[m-1][n-1]",
                "solving_duration_seconds": 19.9,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "31. Next Permutation",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:03:09",
            "details": {
                "final_code": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = n - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        left = i + 1\n        right = n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1",
                "solving_duration_seconds": 16.94,
                "solving_duration_formatted": "0:00:16"
            }
        },
        {
            "problem_title": "93. Restore IP Addresses",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:03:45",
            "details": {
                "final_code": "class Solution(object):\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def isValid(segment):\n            if len(segment) > 1 and segment[0] == '0':\n                return False\n            if int(segment) > 255:\n                return False\n            return True\n\n        def backtrack(start, dots, current_ip, result):\n            if dots == 4:\n                if start == len(s):\n                    result.append(current_ip[:-1])\n                return\n\n            for i in range(start, min(start + 3, len(s))):\n                segment = s[start:i + 1]\n                if isValid(segment):\n                    backtrack(i + 1, dots + 1, current_ip + segment + '.', result)\n\n        result = []\n        backtrack(0, 0, '', result)\n        return result",
                "solving_duration_seconds": 21.21,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "24. Swap Nodes in Pairs",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:04:23",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        current = dummy\n\n        while current.next and current.next.next:\n            first = current.next\n            second = current.next.next\n\n            current.next = second\n            first.next = second.next\n            second.next = first\n\n            current = first\n\n        return dummy.next",
                "solving_duration_seconds": 22.41,
                "solving_duration_formatted": "0:00:22"
            }
        },
        {
            "problem_title": "61. Rotate List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:04:58",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type k: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if not head:\n            return None\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Handle the case where k is larger than the length\n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        # 3. Find the new tail and new head\n        curr = head\n        for _ in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        # 4. Connect the old head to the old tail\n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        curr.next = head\n        \n        return new_head",
                "solving_duration_seconds": 20.66,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "92. Reverse Linked List II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:05:34",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type left: int\n        :type right: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if not head or left == right:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n\n        for _ in range(left - 1):\n            pre = pre.next\n\n        curr = pre.next\n        for _ in range(right - left):\n            nxt = curr.next\n            curr.next = nxt.next\n            nxt.next = pre.next\n            pre.next = nxt\n\n        return dummy.next",
                "solving_duration_seconds": 19.98,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "45. Jump Game II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:06:08",
            "details": {
                "final_code": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        jumps = 0\n        current_reach = 0\n        max_reach = 0\n        \n        for i in range(n - 1):\n            max_reach = max(max_reach, i + nums[i])\n            \n            if i == current_reach:\n                jumps += 1\n                current_reach = max_reach\n                \n        return jumps",
                "solving_duration_seconds": 19.68,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "54. Spiral Matrix",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:06:44",
            "details": {
                "final_code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        if not matrix:\n            return result\n\n        top, bottom = 0, len(matrix) - 1\n        left, right = 0, len(matrix[0]) - 1\n\n        while top <= bottom and left <= right:\n            # Traverse right\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n\n            # Traverse down\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n\n            if top <= bottom and left <= right:\n                # Traverse left\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n\n                # Traverse up\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n\n        return result",
                "solving_duration_seconds": 20.07,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "90. Subsets II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:07:18",
            "details": {
                "final_code": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        def backtrack(index, subset):\n            result.append(subset[:])\n            for i in range(index, len(nums)):\n                if i > index and nums[i] == nums[i-1]:\n                    continue\n                subset.append(nums[i])\n                backtrack(i+1, subset)\n                subset.pop()\n        backtrack(0, [])\n        return result",
                "solving_duration_seconds": 19.74,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "50. Pow(x, n)",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:07:54",
            "details": {
                "final_code": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n == 0:\n            return 1\n        if n < 0:\n            x = 1 / x\n            n = -n\n        \n        res = 1\n        while n > 0:\n            if n % 2 == 1:\n                res *= x\n            x *= x\n            n //= 2\n        return res",
                "solving_duration_seconds": 20.85,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "75. Sort Colors",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:08:29",
            "details": {
                "final_code": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low = 0\n        mid = 0\n        high = len(nums) - 1\n\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1",
                "solving_duration_seconds": 20.14,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "59. Spiral Matrix II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:09:04",
            "details": {
                "final_code": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        top, bottom = 0, n - 1\n        left, right = 0, n - 1\n        direction = 0  # 0: right, 1: down, 2: left, 3: up\n\n        while num <= n * n:\n            if direction == 0:  # right\n                for i in range(left, right + 1):\n                    matrix[top][i] = num\n                    num += 1\n                top += 1\n            elif direction == 1:  # down\n                for i in range(top, bottom + 1):\n                    matrix[i][right] = num\n                    num += 1\n                right -= 1\n            elif direction == 2:  # left\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            elif direction == 3:  # up\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n\n            direction = (direction + 1) % 4\n\n        return matrix",
                "solving_duration_seconds": 20.13,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "109. Convert Sorted List to Binary Search Tree",
            "status": "failed",
            "attempts": 1,
            "timestamp": "2025-04-19 18:09:32",
            "details": {
                "error": "SyntaxError: invalid syntax\n                ^\n    nonlocal head\nLine 37  (Solution.py)",
                "last_code_attempt": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return None\n\n        def get_length(head):\n            length = 0\n            curr = head\n            while curr:\n                length += 1\n                curr = curr.next\n            return length\n\n        def build_bst(start, end):\n            if start > end:\n                return None\n\n            mid = (start + end) // 2\n\n            left = build_bst(start, mid - 1)\n\n            nonlocal head\n            node = TreeNode(head.val)\n            node.left = left\n            head = head.next\n\n            node.right = build_bst(mid + 1, end)\n\n            return node\n\n        length = get_length(head)\n        return build_bst(0, length - 1)",
                "solving_duration_seconds": 13.39,
                "solving_duration_formatted": "0:00:13"
            }
        },
        {
            "problem_title": "96. Unique Binary Search Trees",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:10:07",
            "details": {
                "final_code": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n\n        return dp[n]",
                "solving_duration_seconds": 19.67,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "72. Edit Distance",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:10:43",
            "details": {
                "final_code": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        n = len(word1)\n        m = len(word2)\n\n        # Create a DP table to store the minimum edit distances\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n        # Initialize the first row and column\n        for i in range(n + 1):\n            dp[i][0] = i\n        for j in range(m + 1):\n            dp[0][j] = j\n\n        # Fill in the DP table\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j],      # Deletion\n                                       dp[i][j - 1],      # Insertion\n                                       dp[i - 1][j - 1])  # Replacement\n\n        return dp[n][m]",
                "solving_duration_seconds": 20.54,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "77. Combinations",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:11:18",
            "details": {
                "final_code": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        def backtrack(start, combination):\n            if len(combination) == k:\n                result.append(combination[:])\n                return\n            for i in range(start, n + 1):\n                combination.append(i)\n                backtrack(i + 1, combination)\n                combination.pop()\n        backtrack(1, [])\n        return result",
                "solving_duration_seconds": 19.59,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "89. Gray Code",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:11:53",
            "details": {
                "final_code": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if n == 0:\n            return [0]\n        result = [0, 1]\n        for i in range(2, n + 1):\n            mask = 1 << (i - 1)\n            for j in range(len(result) - 1, -1, -1):\n                result.append(result[j] | mask)\n        return result",
                "solving_duration_seconds": 19.3,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "3. Longest Substring Without Repeating Characters",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:12:28",
            "details": {
                "final_code": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        char_index = {}\n        start = 0\n        max_len = 0\n        for i, char in enumerate(s):\n            if char in char_index and char_index[char] >= start:\n                start = char_index[char] + 1\n            char_index[char] = i\n            max_len = max(max_len, i - start + 1)\n        return max_len",
                "solving_duration_seconds": 20.8,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "64. Minimum Path Sum",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:13:03",
            "details": {
                "final_code": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(grid)\n        n = len(grid[0])\n\n        dp = [[0] * n for _ in range(m)]\n\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n        return dp[m-1][n-1]",
                "solving_duration_seconds": 20.1,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "56. Merge Intervals",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:13:38",
            "details": {
                "final_code": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort(key=lambda x: x[0])\n        \n        merged = []\n        for interval in intervals:\n            if not merged or interval[0] > merged[-1][1]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        \n        return merged",
                "solving_duration_seconds": 19.45,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "57. Insert Interval",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:14:12",
            "details": {
                "final_code": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n\n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n\n        return result",
                "solving_duration_seconds": 19.7,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "133. Clone Graph",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:14:48",
            "details": {
                "final_code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution(object):\n    def cloneGraph(self, node):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        if not node:\n            return None\n        \n        visited = {}\n        \n        def dfs(node):\n            if node in visited:\n                return visited[node]\n            \n            clone_node = Node(node.val)\n            visited[node] = clone_node\n            \n            for neighbor in node.neighbors:\n                clone_node.neighbors.append(dfs(neighbor))\n            \n            return clone_node\n        \n        return dfs(node)",
                "solving_duration_seconds": 21.06,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "137. Single Number II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:15:23",
            "details": {
                "final_code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ones = 0\n        twos = 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones",
                "solving_duration_seconds": 19.33,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "40. Combination Sum II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:15:58",
            "details": {
                "final_code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        candidates.sort()\n\n        def backtrack(combination, remaining, start):\n            if remaining == 0:\n                result.append(list(combination))\n                return\n            \n            if remaining < 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                \n                combination.append(candidates[i])\n                backtrack(combination, remaining - candidates[i], i + 1)\n                combination.pop()\n\n        backtrack([], target, 0)\n        return result",
                "solving_duration_seconds": 20.05,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "143. Reorder List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:16:34",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        if not head or not head.next:\n            return\n\n        # 1. Find the middle of the linked list\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # 2. Reverse the second half of the linked list\n        prev = None\n        curr = slow.next\n        slow.next = None  # Split the list into two halves\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        # 3. Merge the two halves\n        first = head\n        second = prev\n        while second:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2",
                "solving_duration_seconds": 20.64,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "103. Binary Tree Zigzag Level Order Traversal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:17:12",
            "details": {
                "final_code": "from collections import deque\n\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        queue = deque([root])\n        level = 0\n\n        while queue:\n            level_size = len(queue)\n            current_level = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            if level % 2 == 1:\n                result.append(current_level[::-1])\n            else:\n                result.append(current_level)\n\n            level += 1\n\n        return result",
                "solving_duration_seconds": 20.89,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "15. 3Sum",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:17:49",
            "details": {
                "final_code": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total < 0:\n                    left += 1\n                elif total > 0:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n        return result",
                "solving_duration_seconds": 21.05,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "39. Combination Sum",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:18:24",
            "details": {
                "final_code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        \n        def backtrack(combination, remaining, start):\n            if remaining == 0:\n                result.append(list(combination))\n                return\n            \n            if remaining < 0:\n                return\n            \n            for i in range(start, len(candidates)):\n                combination.append(candidates[i])\n                backtrack(combination, remaining - candidates[i], i)\n                combination.pop()\n        \n        backtrack([], target, 0)\n        return result",
                "solving_duration_seconds": 20.91,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "151. Reverse Words in a String",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:18:59",
            "details": {
                "final_code": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        words = s.split()\n        words = [word for word in words if word]\n        words.reverse()\n        return \" \".join(words)",
                "solving_duration_seconds": 20.27,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "47. Permutations II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:19:34",
            "details": {
                "final_code": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        def backtrack(combination, remaining):\n            if not remaining:\n                result.append(combination[:])\n                return\n            \n            for i in range(len(remaining)):\n                if i > 0 and remaining[i] == remaining[i-1]:\n                    continue\n                \n                combination.append(remaining[i])\n                backtrack(combination, remaining[:i] + remaining[i+1:])\n                combination.pop()\n        \n        backtrack([], nums)\n        return result",
                "solving_duration_seconds": 19.65,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "48. Rotate Image",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:20:09",
            "details": {
                "final_code": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        # Transpose the matrix\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # Reverse each row\n        for i in range(n):\n            matrix[i].reverse()",
                "solving_duration_seconds": 19.76,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "53. Maximum Subarray",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:20:44",
            "details": {
                "final_code": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_so_far = nums[0]\n        current_max = nums[0]\n\n        for i in range(1, len(nums)):\n            current_max = max(nums[i], current_max + nums[i])\n            max_so_far = max(max_so_far, current_max)\n\n        return max_so_far",
                "solving_duration_seconds": 20.5,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "80. Remove Duplicates from Sorted Array II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:21:21",
            "details": {
                "final_code": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        k = 0\n        count = 1\n\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                count = 1\n\n            if count <= 2:\n                k += 1\n                nums[k] = nums[i]\n        \n        return k + 1",
                "solving_duration_seconds": 21.14,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "36. Valid Sudoku",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:21:57",
            "details": {
                "final_code": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num == '.':\n                    continue\n\n                if num in rows[i]:\n                    return False\n                rows[i].add(num)\n\n                if num in cols[j]:\n                    return False\n                cols[j].add(num)\n\n                box_index = (i // 3) * 3 + j // 3\n                if num in boxes[box_index]:\n                    return False\n                boxes[box_index].add(num)\n\n        return True",
                "solving_duration_seconds": 20.07,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "71. Simplify Path",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:22:35",
            "details": {
                "final_code": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        parts = path.split('/')\n        for part in parts:\n            if part == '' or part == '.':\n                continue\n            elif part == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(part)\n        \n        return '/' + '/'.join(stack)",
                "solving_duration_seconds": 22.64,
                "solving_duration_formatted": "0:00:22"
            }
        },
        {
            "problem_title": "116. Populating Next Right Pointers in Each Node",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:23:09",
            "details": {
                "final_code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        if not root:\n            return root\n\n        leftmost = root\n\n        while leftmost:\n            curr = leftmost\n            while curr:\n                if curr.left:\n                    curr.left.next = curr.right\n                if curr.right and curr.next:\n                    curr.right.next = curr.next.left\n                curr = curr.next\n            leftmost = leftmost.left\n\n        return root",
                "solving_duration_seconds": 19.74,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "55. Jump Game",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:23:45",
            "details": {
                "final_code": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        reachable = 0\n        for i, jump in enumerate(nums):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + jump)\n        return True",
                "solving_duration_seconds": 19.6,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "153. Find Minimum in Rotated Sorted Array",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:24:16",
            "details": {
                "final_code": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n\n        return nums[left]",
                "solving_duration_seconds": 16.71,
                "solving_duration_formatted": "0:00:16"
            }
        },
        {
            "problem_title": "166. Fraction to Recurring Decimal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:24:52",
            "details": {
                "final_code": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        if numerator == 0:\n            return \"0\"\n\n        sign = \"-\" if (numerator < 0) ^ (denominator < 0) else \"\"\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n\n        integer_part = numerator // denominator\n        remainder = numerator % denominator\n\n        if remainder == 0:\n            return sign + str(integer_part)\n\n        decimal_part = \"\"\n        remainder_map = {}\n        index = 0\n\n        while remainder != 0:\n            if remainder in remainder_map:\n                start_index = remainder_map[remainder]\n                decimal_part = decimal_part[:start_index] + \"(\" + decimal_part[start_index:] + \")\"\n                break\n\n            remainder_map[remainder] = index\n            remainder *= 10\n            decimal_part += str(remainder // denominator)\n            remainder %= denominator\n            index += 1\n\n        return sign + str(integer_part) + \".\" + decimal_part",
                "solving_duration_seconds": 21.41,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "106. Construct Binary Tree from Inorder and Postorder Traversal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:25:28",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not inorder or not postorder:\n            return None\n\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n\n        root_index_inorder = inorder.index(root_val)\n\n        root.left = self.buildTree(inorder[:root_index_inorder], postorder[:root_index_inorder])\n        root.right = self.buildTree(inorder[root_index_inorder+1:], postorder[root_index_inorder:-1])\n\n        return root",
                "solving_duration_seconds": 20.45,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "16. 3Sum Closest",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:26:02",
            "details": {
                "final_code": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        closest_sum = float('inf')\n        \n        for i in range(len(nums) - 2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                if current_sum == target:\n                    return target\n                \n                if abs(current_sum - target) < abs(closest_sum - target):\n                    closest_sum = current_sum\n                \n                if current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return closest_sum",
                "solving_duration_seconds": 19.98,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "91. Decode Ways",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:26:39",
            "details": {
                "final_code": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 0 if s[0] == '0' else 1\n\n        for i in range(2, n + 1):\n            one_digit = int(s[i - 1:i])\n            two_digits = int(s[i - 2:i])\n\n            if 1 <= one_digit <= 9:\n                dp[i] += dp[i - 1]\n            if 10 <= two_digits <= 26:\n                dp[i] += dp[i - 2]\n\n        return dp[n]",
                "solving_duration_seconds": 21.24,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "7. Reverse Integer",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:27:17",
            "details": {
                "final_code": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        sign = -1 if x < 0 else 1\n        x = abs(x)\n        reversed_x = 0\n        while x > 0:\n            digit = x % 10\n            reversed_x = reversed_x * 10 + digit\n            x //= 10\n        \n        reversed_x = sign * reversed_x\n        \n        if reversed_x < -2**31 or reversed_x > 2**31 - 1:\n            return 0\n        else:\n            return reversed_x",
                "solving_duration_seconds": 20.97,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "98. Validate Binary Search Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:27:52",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        def validate(node, low=-float('inf'), high=float('inf')):\n            if not node:\n                return True\n            if node.val <= low or node.val >= high:\n                return False\n\n            return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n        return validate(root)",
                "solving_duration_seconds": 19.86,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "34. Find First and Last Position of Element in Sorted Array",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:28:28",
            "details": {
                "final_code": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def find_start(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        def find_end(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        start = find_start(nums, target)\n        end = find_end(nums, target)\n        return [start, end]",
                "solving_duration_seconds": 21.53,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "128. Longest Consecutive Sequence",
            "status": "failed",
            "attempts": 1,
            "timestamp": "2025-04-19 18:28:56",
            "details": {
                "error": "SyntaxError: invalid syntax\n                                     ^\n    def longestConsecutive(self, nums: list[int]) -> int:\nLine 2  (Solution.py)",
                "last_code_attempt": "class Solution:\n    def longestConsecutive(self, nums: list[int]) -> int:\n        num_set = set(nums)\n        longest_streak = 0\n\n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n\n                longest_streak = max(longest_streak, current_streak)\n\n        return longest_streak",
                "solving_duration_seconds": 12.0,
                "solving_duration_formatted": "0:00:12"
            }
        },
        {
            "problem_title": "117. Populating Next Right Pointers in Each Node II",
            "status": "failed",
            "attempts": 1,
            "timestamp": "2025-04-19 18:29:25",
            "details": {
                "error": "Wrong Answer",
                "failed_cases": [
                    {
                        "Input": "[1,2,3,4,5,null,7]",
                        "Output": "[1,#,2,3,#,4,5,#]",
                        "Expected": "[1,#,2,3,#,4,5,7,#]"
                    },
                    {
                        "Input": "[]",
                        "Output": "[]",
                        "Expected": "[]"
                    }
                ],
                "last_code_attempt": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        if not root:\n            return root\n\n        leftmost = root\n\n        while leftmost:\n            head = leftmost\n            leftmost = None\n\n            while head:\n                if head.left:\n                    if not leftmost:\n                        leftmost = head.left\n                    head.left.next = head.right\n\n                if head.right:\n                    if head.next:\n                        head.right.next = head.next.left\n                    else:\n                        head.right.next = None\n\n                head = head.next\n\n        return root",
                "solving_duration_seconds": 15.03,
                "solving_duration_formatted": "0:00:15"
            }
        },
        {
            "problem_title": "172. Factorial Trailing Zeroes",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:30:01",
            "details": {
                "final_code": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        while n > 0:\n            n //= 5\n            count += n\n        return count",
                "solving_duration_seconds": 20.36,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "150. Evaluate Reverse Polish Notation",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:30:37",
            "details": {
                "final_code": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for token in tokens:\n            if token == '+':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(op1 + op2)\n            elif token == '-':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(op1 - op2)\n            elif token == '*':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(op1 * op2)\n            elif token == '/':\n                op2 = stack.pop()\n                op1 = stack.pop()\n                stack.append(int(float(op1) / op2))\n            else:\n                stack.append(int(token))\n        return stack[0]",
                "solving_duration_seconds": 20.94,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "138. Copy List with Random Pointer",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:31:13",
            "details": {
                "final_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x, next=None, random=None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\nclass Solution(object):\n    def copyRandomList(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        if not head:\n            return None\n\n        # Create a mapping from original nodes to copied nodes\n        node_map = {}\n        curr = head\n        while curr:\n            node_map[curr] = Node(curr.val)\n            curr = curr.next\n\n        # Set the next and random pointers of the copied nodes\n        curr = head\n        while curr:\n            copied_node = node_map[curr]\n            if curr.next:\n                copied_node.next = node_map[curr.next]\n            if curr.random:\n                copied_node.random = node_map[curr.random]\n            curr = curr.next\n\n        return node_map[head]",
                "solving_duration_seconds": 21.4,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "179. Largest Number",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:31:48",
            "details": {
                "final_code": "class Solution(object):\n    def largestNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: str\n        \"\"\"\n        from functools import cmp_to_key\n\n        def compare(n1, n2):\n            if n1 + n2 > n2 + n1:\n                return -1\n            elif n1 + n2 < n2 + n1:\n                return 1\n            else:\n                return 0\n\n        nums = [str(x) for x in nums]\n        nums = sorted(nums, key=cmp_to_key(compare))\n        return str(int(\"\".join(nums)))",
                "solving_duration_seconds": 19.55,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "114. Flatten Binary Tree to Linked List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:32:25",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        def flatten_helper(node):\n            if not node:\n                return None\n\n            left_tail = flatten_helper(node.left)\n            right_tail = flatten_helper(node.right)\n\n            if left_tail:\n                original_right = node.right\n                node.right = node.left\n                node.left = None\n                left_tail.right = original_right\n\n                if right_tail:\n                    return right_tail\n                else:\n                    return original_right if original_right else left_tail\n            else:\n                return right_tail if right_tail else node\n\n        flatten_helper(root)",
                "solving_duration_seconds": 21.23,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "204. Count Primes",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:33:00",
            "details": {
                "final_code": "class Solution(object):\n    def countPrimes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 2:\n            return 0\n        \n        isPrime = [True] * n\n        isPrime[0] = isPrime[1] = False\n        \n        for i in range(2, int(n**0.5) + 1):\n            if isPrime[i]:\n                for j in range(i*i, n, i):\n                    isPrime[j] = False\n        \n        return sum(isPrime)",
                "solving_duration_seconds": 20.77,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "73. Set Matrix Zeroes",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:33:36",
            "details": {
                "final_code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        first_row_zero = False\n        first_col_zero = False\n        \n        for i in range(m):\n            if matrix[i][0] == 0:\n                first_col_zero = True\n                break\n        \n        for j in range(n):\n            if matrix[0][j] == 0:\n                first_row_zero = True\n                break\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if first_row_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n        \n        if first_col_zero:\n            for i in range(m):\n                matrix[i][0] = 0",
                "solving_duration_seconds": 20.52,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "29. Divide Two Integers",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:34:12",
            "details": {
                "final_code": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n\n        sign = (dividend > 0) ^ (divisor > 0)\n        dividend = abs(dividend)\n        divisor = abs(divisor)\n\n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            multiple = 1\n            while dividend >= (temp << 1) and (temp << 1) > 0:\n                temp <<= 1\n                multiple <<= 1\n            dividend -= temp\n            quotient += multiple\n\n        if sign:\n            quotient = -quotient\n\n        return max(-2147483648, min(quotient, 2147483647))",
                "solving_duration_seconds": 20.1,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "189. Rotate Array",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:34:48",
            "details": {
                "final_code": "class Solution(object):\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        k %= n\n        \n        def reverse(l, r):\n            while l < r:\n                nums[l], nums[r] = nums[r], nums[l]\n                l += 1\n                r -= 1\n        \n        reverse(0, n - 1)\n        reverse(0, k - 1)\n        reverse(k, n - 1)",
                "solving_duration_seconds": 20.83,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "12. Integer to Roman",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:35:24",
            "details": {
                "final_code": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        roman_map = { 1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'}\n        integers = sorted(roman_map.keys(), reverse=True)\n        result = \"\"\n        for i in integers:\n            while num >= i:\n                result += roman_map[i]\n                num -= i\n        return result",
                "solving_duration_seconds": 21.07,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "2563. Count the Number of Fair Pairs",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:35:58",
            "details": {
                "final_code": "class Solution(object):\n    def countFairPairs(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            left = i + 1\n            right = n - 1\n            lower_bound = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[i] + nums[mid] >= lower:\n                    lower_bound = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n\n            left = i + 1\n            right = n - 1\n            upper_bound = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[i] + nums[mid] <= upper:\n                    upper_bound = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n            if lower_bound != -1 and upper_bound != -1:\n                if lower_bound <= upper_bound:\n                    count += (upper_bound - lower_bound + 1)\n        return count",
                "solving_duration_seconds": 20.55,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "43. Multiply Strings",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:36:34",
            "details": {
                "final_code": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        product = [0] * (m + n)\n\n        for i in range(m - 1, -1, -1):\n            carry = 0\n            for j in range(n - 1, -1, -1):\n                product[i + j + 1] += int(num1[i]) * int(num2[j]) + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n            product[i] += carry\n\n        result = \"\".join(map(str, product))\n        while result[0] == '0' and len(result) > 1:\n            result = result[1:]\n        return result",
                "solving_duration_seconds": 20.48,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "31. Next Permutation",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:37:09",
            "details": {
                "final_code": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = n - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        left = i + 1\n        right = n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1",
                "solving_duration_seconds": 20.88,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "200. Number of Islands",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:37:46",
            "details": {
                "final_code": "class Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n\n        rows, cols = len(grid), len(grid[0])\n        num_islands = 0\n\n        def dfs(row, col):\n            if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == '0':\n                return\n\n            grid[row][col] = '0'  # Mark as visited (water)\n\n            # Explore adjacent cells\n            dfs(row + 1, col)\n            dfs(row - 1, col)\n            dfs(row, col + 1)\n            dfs(row, col - 1)\n\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == '1':\n                    num_islands += 1\n                    dfs(i, j)\n\n        return num_islands",
                "solving_duration_seconds": 19.78,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "81. Search in Rotated Sorted Array II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:38:23",
            "details": {
                "final_code": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            \n            if nums[left] == nums[mid] and nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False",
                "solving_duration_seconds": 20.4,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "129. Sum Root to Leaf Numbers",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:38:58",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        def dfs(node, current_number):\n            if not node:\n                return 0\n\n            current_number = current_number * 10 + node.val\n\n            if not node.left and not node.right:\n                return current_number\n\n            return dfs(node.left, current_number) + dfs(node.right, current_number)\n\n        return dfs(root, 0)",
                "solving_duration_seconds": 19.69,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "210. Course Schedule II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:39:34",
            "details": {
                "final_code": "class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        indegree = [0] * numCourses\n        graph = [[] for _ in range(numCourses)]\n\n        for course, pre in prerequisites:\n            indegree[course] += 1\n            graph[pre].append(course)\n\n        queue = []\n        for i in range(numCourses):\n            if indegree[i] == 0:\n                queue.append(i)\n\n        result = []\n        while queue:\n            course = queue.pop(0)\n            result.append(course)\n\n            for neighbor in graph[course]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        if len(result) == numCourses:\n            return result\n        else:\n            return []",
                "solving_duration_seconds": 20.99,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "148. Sort List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:40:13",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        # 1. Split the list into two halves\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n\n        # 2. Recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n\n        # 3. Merge the sorted halves\n        dummy = ListNode(0)\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n\n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n\n        return dummy.next",
                "solving_duration_seconds": 21.86,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "97. Interleaving String",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:40:50",
            "details": {
                "final_code": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        len1, len2, len3 = len(s1), len(s2), len(s3)\n        if len1 + len2 != len3:\n            return False\n\n        dp = [[False] * (len2 + 1) for _ in range(len1 + 1)]\n        dp[0][0] = True\n\n        for i in range(1, len1 + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n        for j in range(1, len2 + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n        for i in range(1, len1 + 1):\n            for j in range(1, len2 + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                           (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n        return dp[len1][len2]",
                "solving_duration_seconds": 21.85,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "201. Bitwise AND of Numbers Range",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:41:26",
            "details": {
                "final_code": "class Solution(object):\n    def rangeBitwiseAnd(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        shift = 0\n        while left != right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        return left << shift",
                "solving_duration_seconds": 20.39,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "102. Binary Tree Level Order Traversal",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:42:02",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        queue = [root]\n\n        while queue:\n            level_size = len(queue)\n            current_level = []\n\n            for _ in range(level_size):\n                node = queue.pop(0)\n                current_level.append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.append(current_level)\n\n        return result",
                "solving_duration_seconds": 21.15,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "227. Basic Calculator II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:42:39",
            "details": {
                "final_code": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.strip()\n        stack = []\n        num = 0\n        op = '+'\n        \n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if s[i] in '+-*/' or i == len(s) - 1:\n                if op == '+':\n                    stack.append(num)\n                elif op == '-':\n                    stack.append(-num)\n                elif op == '*':\n                    stack.append(stack.pop() * num)\n                else:\n                    top = stack.pop()\n                    if top < 0 and num > 0:\n                        stack.append(-(abs(top) // num))\n                    else:\n                        stack.append(top // num)\n                op = s[i]\n                num = 0\n        \n        return sum(stack)",
                "solving_duration_seconds": 21.4,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "199. Binary Tree Right Side View",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:43:16",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def rightSideView(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        queue = [root]\n\n        while queue:\n            level_size = len(queue)\n            rightmost_node = None\n\n            for i in range(level_size):\n                node = queue.pop(0)\n                rightmost_node = node\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.append(rightmost_node.val)\n\n        return result",
                "solving_duration_seconds": 22.25,
                "solving_duration_formatted": "0:00:22"
            }
        },
        {
            "problem_title": "236. Lowest Common Ancestor of a Binary Tree",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:43:54",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n\n        if root == p or root == q:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n        elif left:\n            return left\n        else:\n            return right",
                "solving_duration_seconds": 21.12,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "86. Partition List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:44:30",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type x: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        less_head = ListNode(0)\n        greater_head = ListNode(0)\n        less_tail = less_head\n        greater_tail = greater_head\n\n        curr = head\n        while curr:\n            if curr.val < x:\n                less_tail.next = curr\n                less_tail = curr\n            else:\n                greater_tail.next = curr\n                greater_tail = curr\n            curr = curr.next\n\n        greater_tail.next = None\n        less_tail.next = greater_head.next\n\n        return less_head.next",
                "solving_duration_seconds": 20.37,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "146. LRU Cache",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:45:04",
            "details": {
                "final_code": "class LRUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add(node)\n            return node.val\n        else:\n            return -1\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n        node = Node(key, value)\n        self._add(node)\n        self.cache[key] = node\n        if len(self.cache) > self.capacity:\n            node = self.head.next\n            self._remove(node)\n            del self.cache[node.key]\n\n    def _add(self, node):\n        prev = self.tail.prev\n        prev.next = node\n        node.prev = prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def _remove(self, node):\n        prev = node.prev\n        next_node = node.next\n        prev.next = next_node\n        next_node.prev = prev\n\n\nclass Node:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None",
                "solving_duration_seconds": 19.59,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "162. Find Peak Element",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:45:40",
            "details": {
                "final_code": "class Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left",
                "solving_duration_seconds": 19.58,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "230. Kth Smallest Element in a BST",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:46:17",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def kthSmallest(self, root, k):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        stack = []\n        curr = root\n        n = 0\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            n += 1\n            if n == k:\n                return curr.val\n            curr = curr.right",
                "solving_duration_seconds": 20.36,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "2. Add Two Numbers",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:46:53",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: Optional[ListNode]\n        :type l2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        carry = 0\n        dummy_head = ListNode(0)\n        current = dummy_head\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            sum_val = val1 + val2 + carry\n            carry = sum_val // 10\n            digit = sum_val % 10\n\n            current.next = ListNode(digit)\n            current = current.next\n\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n\n        return dummy_head.next",
                "solving_duration_seconds": 20.96,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "241. Different Ways to Add Parentheses",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:47:27",
            "details": {
                "final_code": "class Solution(object):\n    def diffWaysToCompute(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: List[int]\n        \"\"\"\n        if expression.isdigit():\n            return [int(expression)]\n        \n        results = []\n        for i, char in enumerate(expression):\n            if char in ['+', '-', '*']:\n                left_results = self.diffWaysToCompute(expression[:i])\n                right_results = self.diffWaysToCompute(expression[i+1:])\n                \n                for left in left_results:\n                    for right in right_results:\n                        if char == '+':\n                            results.append(left + right)\n                        elif char == '-':\n                            results.append(left - right)\n                        else:\n                            results.append(left * right)\n        return results",
                "solving_duration_seconds": 19.89,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "113. Path Sum II",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:48:04",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        def dfs(node, current_sum, path):\n            if not node:\n                return\n            \n            current_sum += node.val\n            path.append(node.val)\n            \n            if not node.left and not node.right:\n                if current_sum == targetSum:\n                    result.append(list(path))\n            else:\n                dfs(node.left, current_sum, path)\n                dfs(node.right, current_sum, path)\n            \n            path.pop()\n        \n        dfs(root, 0, [])\n        return result",
                "solving_duration_seconds": 21.24,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "147. Insertion Sort List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:48:40",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr and curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                node_to_insert = curr.next\n                curr.next = curr.next.next\n                \n                prev = dummy\n                while prev.next.val < node_to_insert.val:\n                    prev = prev.next\n                \n                node_to_insert.next = prev.next\n                prev.next = node_to_insert\n        \n        return dummy.next",
                "solving_duration_seconds": 20.16,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "223. Rectangle Area",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:49:16",
            "details": {
                "final_code": "class Solution(object):\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n        \"\"\"\n        :type ax1: int\n        :type ay1: int\n        :type ax2: int\n        :type ay2: int\n        :type bx1: int\n        :type by1: int\n        :type bx2: int\n        :type by2: int\n        :rtype: int\n        \"\"\"\n        area1 = (ax2 - ax1) * (ay2 - ay1)\n        area2 = (bx2 - bx1) * (by2 - by1)\n\n        overlap_width = max(0, min(ax2, bx2) - max(ax1, bx1))\n        overlap_height = max(0, min(ay2, by2) - max(ay1, by1))\n\n        overlap_area = overlap_width * overlap_height\n\n        return area1 + area2 - overlap_area",
                "solving_duration_seconds": 20.35,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "153. Find Minimum in Rotated Sorted Array",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:49:51",
            "details": {
                "final_code": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n\n        return nums[left]",
                "solving_duration_seconds": 20.92,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "8. String to Integer (atoi)",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:50:29",
            "details": {
                "final_code": "class Solution(object):\n    def myAtoi(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        start = 0\n        if s[0] == '+':\n            start = 1\n        elif s[0] == '-':\n            sign = -1\n            start = 1\n\n        result = 0\n        for i in range(start, len(s)):\n            if not s[i].isdigit():\n                break\n            digit = int(s[i])\n            result = result * 10 + digit\n\n        result *= sign\n\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        if result > INT_MAX:\n            return INT_MAX\n        elif result < INT_MIN:\n            return INT_MIN\n        else:\n            return result",
                "solving_duration_seconds": 23.54,
                "solving_duration_formatted": "0:00:23"
            }
        },
        {
            "problem_title": "173. Binary Search Tree Iterator",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:51:03",
            "details": {
                "final_code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        self.stack = []\n        self._push_left(root)\n\n    def _push_left(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        node = self.stack.pop()\n        self._push_left(node.right)\n        return node.val\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack) > 0\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()",
                "solving_duration_seconds": 18.93,
                "solving_duration_formatted": "0:00:18"
            }
        },
        {
            "problem_title": "209. Minimum Size Subarray Sum",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:51:40",
            "details": {
                "final_code": "class Solution(object):\n    def minSubArrayLen(self, target, nums):\n        \"\"\"\n        :type target: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        window_start = 0\n        window_sum = 0\n        min_length = float('inf')\n\n        for window_end in range(len(nums)):\n            window_sum += nums[window_end]\n\n            while window_sum >= target:\n                min_length = min(min_length, window_end - window_start + 1)\n                window_sum -= nums[window_start]\n                window_start += 1\n\n        if min_length == float('inf'):\n            return 0\n        else:\n            return min_length",
                "solving_duration_seconds": 21.25,
                "solving_duration_formatted": "0:00:21"
            }
        },
        {
            "problem_title": "216. Combination Sum III",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:52:17",
            "details": {
                "final_code": "class Solution(object):\n    def combinationSum3(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n\n        def backtrack(combination, remaining, start):\n            if len(combination) == k and remaining == 0:\n                result.append(list(combination))\n                return\n            if len(combination) == k or remaining < 0:\n                return\n\n            for i in range(start, 10):\n                combination.append(i)\n                backtrack(combination, remaining - i, i + 1)\n                combination.pop()\n\n        backtrack([], n, 1)\n        return result",
                "solving_duration_seconds": 20.69,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "260. Single Number III",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:52:53",
            "details": {
                "final_code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        xor_sum = 0\n        for num in nums:\n            xor_sum ^= num\n        \n        rightmost_set_bit = xor_sum & -xor_sum\n        \n        num1 = 0\n        num2 = 0\n        \n        for num in nums:\n            if num & rightmost_set_bit:\n                num1 ^= num\n            else:\n                num2 ^= num\n        \n        return [num1, num2]",
                "solving_duration_seconds": 20.98,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "198. House Robber",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:53:28",
            "details": {
                "final_code": "class Solution(object):\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        \n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, n):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n            \n        return dp[n-1]",
                "solving_duration_seconds": 19.99,
                "solving_duration_formatted": "0:00:19"
            }
        },
        {
            "problem_title": "237. Delete Node in a Linked List",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:54:20",
            "details": {
                "final_code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next",
                "solving_duration_seconds": 37.1,
                "solving_duration_formatted": "0:00:37"
            }
        },
        {
            "problem_title": "130. Surrounded Regions",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:54:56",
            "details": {
                "final_code": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n\n        m, n = len(board), len(board[0])\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'  # Mark as temporary\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        # Mark 'O's connected to the boundary as 'T'\n        for i in range(m):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][n - 1] == 'O':\n                dfs(i, n - 1)\n\n        for j in range(n):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[m - 1][j] == 'O':\n                dfs(m - 1, j)\n\n        # Replace 'O's with 'X's and 'T's with 'O's\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'",
                "solving_duration_seconds": 20.57,
                "solving_duration_formatted": "0:00:20"
            }
        },
        {
            "problem_title": "208. Implement Trie (Prefix Tree)",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:55:30",
            "details": {
                "final_code": "class Trie(object):\n    def __init__(self):\n        self.root = {}\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node:\n                return False\n            node = node[char]\n        return True",
                "solving_duration_seconds": 18.64,
                "solving_duration_formatted": "0:00:18"
            }
        },
        {
            "problem_title": "207. Course Schedule",
            "status": "solved",
            "attempts": 1,
            "timestamp": "2025-04-19 18:56:04",
            "details": {
                "final_code": "class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            indegree[course] += 1\n\n        queue = [i for i in range(numCourses) if indegree[i] == 0]\n        count = 0\n\n        while queue:\n            course = queue.pop(0)\n            count += 1\n\n            for neighbor in graph[course]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return count == numCourses",
                "solving_duration_seconds": 20.03,
                "solving_duration_formatted": "0:00:20"
            }
        }
    ],
    "statistics": {
        "total_attempted": 100,
        "total_solved": 97,
        "accuracy": 97.0
    }
}